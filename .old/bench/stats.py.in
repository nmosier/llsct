#!${Python3_EXECUTABLE}

import argparse
import sys
import os
import json
import collections

parser = argparse.ArgumentParser()
parser.add_argument('--logs', required = True)
parser.add_argument('--json', required = True)
parser.add_argument('--func', required = True)
parser.add_argument('-o', dest = 'out', type = argparse.FileType('w'), default = sys.stdout)
args = parser.parse_args()

with open(args.json) as f:
    stats = json.load(f)

out = args.out

warned = set() 

if not os.path.isdir(args.logs):
    print(f'not a directory: {args.logs}', file = sys.stderr)
    exit(1)

def json_for_function(function):
    path = f'{args.logs}/{function}.json'
    try:
        with open(path, 'r') as f:
            j = json.load(f)
        return j
    except:
        if path not in warned and not path.split('/')[-1].startswith('llvm.'):
            warned.add(path)
            print(f'warning: couldn\'t open {path}', file = sys.stderr)
        return None

def jsons_for_functions(function):
    j = json_for_function(function)
    if j is None:
        return []
    js = [j]
    for callee in j['callees']:
        js.extend(jsons_for_functions(callee))
    return js

# return aggregate json for benchmark
js = jsons_for_functions(args.func)
combined = collections.defaultdict(lambda: 0)
combined['functions'] = []
for j in js:
    combined['functions'].append(j['function_name'])
    for stat in stats:
        name = stat
        if name not in j:
            print(f'missing stat "{name}"', file = sys.stderr)
            exit(1)
        combined[name] += j[name]
combined['num_functions'] = len(js)
json.dump(combined, out)
