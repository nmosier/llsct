#!${Python3_EXECUTABLE}

import argparse
import sys
import os
import tempfile
import json
import matplotlib.pyplot as plt
import seaborn
import pandas

parser = argparse.ArgumentParser()
parser.add_argument('tests')
parser.add_argument('outdir')
parser.add_argument('--skip', action = 'store_true')
parser.add_argument('-n', type = int, default = 5)

args = parser.parse_args()

with open(args.tests) as f:
    spec = json.load(f)

baseline = None
partials = []
fulls = []
sums = []

name_to_record = {}

os.makedirs(args.outdir, exist_ok = True)


def overhead_of(a, b):
    return (a - b) / b * 100


# Run each benchmark and save results in JSON.
# Create benchmarks dictionary: benchmark_name -> json
benchmarks = dict()
for benchmark in spec['benchmarks']:
    name = benchmark['name']
    jsonpath = f'{args.outdir}/{name}.json'
    if not args.skip:
        if os.system('{} --benchmark_out={} --benchmark_out_format=json --benchmark_repetitions={}'.format(benchmark['path'], jsonpath, args.n)):
            print('benchmark failed to run, exiting...', file = sys.stderr)
            exit(1)
    with open(jsonpath) as f:
        j = json.load(f)
    k = j['benchmarks']
    mean = '_mean'
    k = [d for d in k if d['name'].endswith(mean)]
    xs = [int(d['name'][:-len(mean)].split('/')[-1]) for d in k]
    ys = [float(d['cpu_time']) for d in k]
    benchmarks[name] = {'x': xs, 'y': ys}

# Create plots
for plot in spec['plots']:
    baseline_name = plot['baseline']
    baseline_xs = benchmarks[baseline_name]['x']
    baseline_ys = benchmarks[baseline_name]['y']
    N = len(baseline_ys)
    table = {'name': [], 'x': [], 'y': []}
    for line in plot['lines']:
        overhead = [float(0)] * N
        for source in line['sources']:
            source_ys = benchmarks[source]['y']
            for i in range(N):
                overhead[i] += overhead_of(source_ys[i], baseline_ys[i])
        table['name'].extend([line['name']] * N)
        table['x'].extend(baseline_xs)
        table['y'].extend(overhead)

    # generate dataframe
    df = pandas.DataFrame(data = table)
    ax = seaborn.lineplot(
        data = df,
        x = 'x',
        y = 'y',
        hue = 'name',
    )
    ax.set(xscale = 'log')
    if 'axes' in plot:
        ax.set(**plot['axes'])
    plt.xticks(
        ticks = baseline_xs,
        labels = baseline_xs,
    )

    line_styles = dict([(line['name'], line['style']) for line in plot['lines']])

    # Set line styles
    M = len(plot['lines'])
    assert M * 2 == len(ax.lines)
    for i in range(M):
        line1 = ax.lines[i]
        line2 = ax.lines[i + M]
        style = line_styles[line2._label]
        line1.set_linestyle(style)
        line2.set_linestyle(style)
    for line in ax.legend().get_lines():
        line.set_linestyle(line_styles[line._label])

    plt.savefig('{}/{}'.format(args.outdir, plot['filename']))
    plt.clf()

    
exit(0)

    


for test in tests:
    k = test['type']
    outpath = '{}/{}.json'.format(args.outdir, test['name'])
    record = {'name': test['name'], 'bytes': [], 'time': [], 'percent': []}
    name_to_record[test['name']] = record

    if k == 'sum':
        record['bytes'] = baseline['bytes']
        record['time'] = list(baseline['time'])
        for partname in test['parts']:
            for i, value in enumerate(name_to_record[partname]['time']):
                record['time'][i] += value - baseline['time'][i]
    else:
        if not args.skip:
            if os.system('{} --benchmark_out={} --benchmark_out_format=json'.format(test['path'], outpath)):
                print('benchmark failed to run, exiting...', file = sys.stderr)
                exit(1)
        with open(outpath) as f:
            j = json.load(f)
        for d in j['benchmarks']:
            record['bytes'].append(int(d['name'].split('/')[-1]))
            record['time'].append(d['cpu_time'])
    if k == 'baseline':
        baseline = record
    elif k == 'partial':
        partials.append(record)
    elif k == 'full':
        fulls.append(record)
    elif k == 'sum':
        sums.append(record)
    else:
        assert False

# Some consistency checks
for partial in partials:
    assert partial['bytes'] == baseline['bytes']
for full in fulls:
    assert full['bytes'] == baseline['bytes']

partial_names = [partial['name'] for partial in partials]
full_names = [full['name'] for full in fulls]
baseline_name = baseline['name']
sum_names = [sum['name'] for sum in sums]

# Compute percentages
def compute_percentages(record):
    record['percent'] = [(b / a - 1) * 100 for a, b in zip(baseline['time'], record['time'])]

compute_percentages(baseline)
for partial in partials:
    compute_percentages(partial)
for full in fulls:
    compute_percentages(full)
for sum in sums:
    compute_percentages(sum)

# Create long format dict
results = {'name': [], 'bytes': [], 'time': [], 'percent': []}
def add_record(record):
    record['name'] = [record['name']] * len(record['bytes'])
    for key in record:
        results[key].extend(record[key])

add_record(baseline)
for partial in partials:
    add_record(partial)
for full in fulls:
    add_record(full)
for sum in sums:
    add_record(sum)

df = pandas.DataFrame(data = results)
ax = seaborn.lineplot(
    data = df,
    x = 'bytes',
    y = 'percent',
    hue = 'name',
)
ax.set(
    xlabel = 'input size (bytes)',
    ylabel = 'overhead (%)', # TODO: automatically infer unit
    xscale = 'log',
)
plt.xticks(ticks = baseline['bytes'], labels = baseline['bytes'])

num_lines = int(len(ax.lines) / 2)

ax.lines[0].set(linestyle = ':')
ax.lines[num_lines].set(linestyle = ':')

def label_to_style(l):
    if l == baseline_name:
        return ':'
    elif l in partial_names:
        return '--'
    elif l in full_names:
        return '-'
    elif l in sum_names:
        return '-.'
    else:
        assert False

for i in range(num_lines):
    line1 = ax.lines[i]
    line2 = ax.lines[i + num_lines]
    label = line2._label
    style = label_to_style(label)
    line1.set_linestyle(style)
    line2.set_linestyle(style)

for line in ax.legend().get_lines():
    style = label_to_style(line._label)
    line.set_linestyle(style)

plt.legend(
    ncols = 2,
    # bbox_to_anchor = (0.6, 1.1),
    # loc = 'upper right',
    fontsize = 'small',
)
plt.savefig('{}/plot.svg'.format(args.outdir), bbox_inches = 'tight')
